\section{Implementation} \label{sec:implement}

\subsection{Pre-processor} \label{sec:preprocessor}
The format of a BG database is a bit-vector table.
%We compress the branch information and gadget analysis results into bit-vectors.
We choose bit-vectors, instead of hash tables, because
the bit-vector indexing is more efficient and stable. For bit-vector, the time
cost of a query is only one memory access without false positive,
while for hash table, the time cost of a query is the computation cost of
the hash function plus one or more memory access if there is a collision.

The conversion algorithm for building bit-vectors is as follows. For each of them,
we find out the size of the executable segment
from the header information of the application binary, and allocate
a bit-vector of proper length.
The bit-vectors are indexed by the byte offset of the executable code segment.
Each byte in the application executable segment will occupy
four bits in our implementation.
The value stored in the four-bit slot
is decided by the branch type of the instruction that starts at this byte,
and the information of the potential gadget that begins at the instruction.
We use \emph{readelf} program to parse the binary header information, and
{objdump} to disassemble the application binary. We write a script to extract
all aligned branch instructions and their byte offset from objdump output.
Then, we leverage the disassembly library diStorm~\cite{distorm} to
analyze the gadget information in the application binary. Specifically,
for each byte in the executable code segment, we run diStorm to try disassembling six
instructions starting at that byte. If indirect branch is found among
those six instructions, we further process the disassembled instructions
before that indirect branch to figure out the stack manipulation.

Our bit-vector mechanism is space-efficient. The bit-vectors for all shared libraries
under \emph{/lib} and \emph{/usr/lib} of the Ubuntu Linux 12.04 distribution is about $548MB$.
It turns out that compression rate of our bit-vectors are quite high, because the potential
gadgets and branch instructions are sparse in the application binary.
For instance, the bit-vectors for the above shared libraries can be compressed to about $46MB$
using bzip2. The compress rate is about $91.6\%$.


\subsection{Run-time Checking} \label{sec:checker}
\name is implemented as a loadable Linux kernel module
that executes the detection algorithms described in
Section~\ref{sec:algo} to identify and confirm ROP attack payload.

\mypara{Memory Mapping Parsing}
The run-time checker should acquire the virtual memory mapping of the target
application and all its shared libraries. If ASLR is enabled,
the shared libraries are loaded in random base address. We implement
system calls hooks (by modifying the system call table) in our kernel module to intercept execve (for intercepting application), open/close and
mmap/munmap (for intercepting shared libraries) and to parse the loaded libraries' base addresses. The overhead is quite slight since it is only one comparison for identifying the process ID. Furthermore, this overhead may be avoidable
if the mapping information is provided by a daemon process through a dedicated system calls,
rather than using the interception technique.
Note that the interception may affect
other applications coexisting in the system if they also use the intercepted system calls.


\mypara{Monitor Window Setting}
We leverage the NX (Never eXecute) page table permission, in any DEP-capable modern processor,
to set up monitor window. At the beginning, \name sets the NX bits in the loaded virtual memory
pages of the application and library code.
During execution, the application will trigger page
faults by trying to execute code in non-executable pages. \name intercepts
page faults by modifying the interrupt table (IDT), and identifies the relevant
faults by using process ID and page fault error code.
\name always enables the executable permissions of the most recent accessed code
pages that fit in the monitor window size. Thus, after each page fault triggered by
jumping out of the monitor window, \name adds the new memory page that the application
intends to access into the window, and kicks one page out of the monitor window, if the total
number of executable code page exceeds the window size.
The update policy may be the First In First Out (FIFO), First In Last Out (FILO)
or the Least Recently Used(LRU), which can be configured by the end user to adapt to
different code locality features of different application.

\mypara{Payload Detection}
In the payload detection, we have to find out gadget pointers from stack and verify if they can be linked together.
%how do find/determine the pointed code is a gadget
To determine whether a stack entry (4 bytes on x86-32 platform) is a gadget pointer,
\name first determines if it points to the code region. Recall that \name records
the base addresses and sizes of the code segments of the share libraries and the application.
If the stack entry does point to the code region,
\name then searches in the corresponding database to determine if it points to a
gadget and what stack-manipulation to take. Note that there are a few of gadget cases
whose stack-manipulation actions are not covered in the BG database.
(1) The stack-manipulation actions are dynamically determined in run-time, e.g.,
\emph{mov \%eax, \%esp; ret}, and \emph{pop \%esp; ret}. It seems that the gadgets like \emph{pop \%esp} only appears in unaligned gadgets,
and thus will be detected in our branch alignment filtering step.
For the gadgets are aligned, we can emulate it at run-time. Note that many modern Operating Systems (e.g., Linux) have the instruction emulation functionality. Thus we do not need to build the emulator from scratch.
(2) The stack adjust value is too large, e.g., \emph{add 0x34, \%esp}. In the BG database, there are only 4 bits for a gadget. Thus it can only support 16 states. For the gadgets whose the adjust value is larger than the state space, \name has to analyze them at run-time.


\mypara{Feedback Confirmation Policies}
Once the feedback confirmation mechanism is activated, \name will verify whether the identified gadget chain is executed.
Specifically, for each gadget pointer in the gadget chain, \name will find it in the taken branches recorded from the LBR registers.
If all of them have been recorded, \name will terminate the application immediately.
% how many matching
If some of them are not there, \name will pass this checking and hold the gadget chain for the further checking.
% how to update the gadget chain
The gadget chain may be updated by the following payload detection algorithm. If the two gadget chains can be merged (i.e., the tail elements of the former gadget chain is the same as the head elements of the later one), \name will extend the gadget chains to a longer chain. Otherwise, it will totally replace the old chain.




\mypara{System Calls Interception}
Besides the check points triggered by the monitor window, there are several system calls to be intercepted and checked. The reason is that they may be used by the adversary to disable or bypass some essential security mechanisms, such as circumventing the DEP mechanism.

The first system call is the \emph{mprotect}, which is able to change the permission of a memory region. The adversary usually use it to subvert the DEP mechanism, e.g., change the writable memory regions to be executable, or set the code regions writable. In order to stop such attacks, we should check the \emph{mprotect} request before pass it to the kernel. Specifically, we have two main step to check the request. We first check the request according to basic security policies: 1) The code regions that have been recorded should be readonly. Any request that attempts to set it writable  will be rejected. 2) The data regions should be non-executable. Any request that aims to set the data regions executable will be rejected. The second step is to leverage the ROP checking algorithm to ensure that there is no ROP payload in the current stack. Only the requests that pass all checking steps are sent to the kernel, otherwise ROPTerminator will return the system call with a error code to indicate the failure of the request.

The second system call is the \emph{execve} which is able to start a new process with some prepared input parameters. For instance, the adversary may use the libc function \emph{system} or directly invoke the system call \emph{execve} to open a shell, in which the adversary is able to execute  arbitrary commands.
The end user can create a simple policy: ROPTerminator directly rejects all such requests for all selected applications. In most cases, it works well. However, for some legitimate applications, they may also send such requests for certain purposes. The first policy may lead to the non-coexistence of ROP with these applications.
To support such applications, ROPTerminator can be configured to launch the ROP checking algorithm to verify if there is a ROP attack. If not, ROPTerminator passes the request to the kernel. By doing so, ROPTerminator and such applications can coexist, but the performance overhead may increase due to the extra checking.

Similarly, the ROP checking algorithm should be enforced before the kernel handles the system calls \emph{setuid} and \emph{mmap}.

