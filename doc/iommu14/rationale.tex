\section{Design Rationale}\label{sec:rationale}

This section analyzes several challenges of ROP attack detection, and introduces the main ideas and design decisions of ROPTerminator.

\mypara{When to perform ROP checking}
The timing of the ROP checking is critical, since it will directly affect the accuracy and performance.
As in G3, our ROPTerminator aims to protect any unmodified applications. Thus, we cannot leverage binary instrumentation to insert code in critical execution paths of the protected application, to trigger our ROP checking. It is obviously not efficient to monitor every operation of the application. while sampling in a constant or random frequency would improve the performance but is likely to introduce high false negative rate, since the ROP attacks may happen between two sampling points. %Thus, we need to choose an appropriate checking point to involve the ROP checking algorithm with low performance overhead. %can not give us the confidence that it can catch the ROP attack as long as it is really happened.

In this paper, we propose to monitor the application through a sliding window, in which the application code is set executable by ROPTerminator,
while the rest of code is non-executable. The execution flow, when jumping out of this window, will automatically trigger our ROP checking logic.
This monitor window design is reasonable because of the following two reasons. (1) The window size is small comparing with the large code base that is needed in launching a meaningful ROP attack. The attack cannot be finished within a window, so it will always trigger multiple instances of ROP checking. This is non-bypassable, because a user-space ROP attacker cannot disable the monitor window set by ROPTerminator from kernel-space.
(2) The performance overhead of the monitor window introduce is quite small, since there is no intervention for the operations running within the monitor window. In addition, the checking procedure is not triggered frequently due to the temporal and spatial locality feature of the execution~\cite{ulk}.


\mypara{How to defend against ROP attacks}
Based on different characteristics of ROP attacks, researchers have proposed several approaches to detect ROP attacks.

Some of the previous approaches observe that the traditional ROP attacks (ret-based ROP) violate the call-ret pairs. Thus, they proposed several approaches ~\cite{ropdefender,drop} to check if there is call-ret violation in runtime. Obviously, such approaches are able to detect the ret-based ROP attacks, but fail to handle the jmp/call-based ROP (conflicting our G1). Moreover, these methods incur unbearable performance overhead, because the checking procedure will be involved with every execution of the ret instruction.
Given that all ROP attacks violate the Control Flow Graph (CFG) and Call Graph (CG), some approaches~\cite{cfi,cflocking} are proposed to verify the control flow integrity in runtime. Note that such information is extremely difficult to extract \emph{completely} and \emph{accurately} from the (stripped) binary code. They have to rely on source code access and/or customized compiler tool-chain, thus violating G2.
Some other approaches~\cite{smashing,g-free} aim to remove gadgets from the binary code. However, such approaches usually can not give a clear answer on whether the remaining non-removed gadgets would be sufficient for constructing meaningful ROP attack. In addition, some of them may need source code and customized compiler tool-chain.
%Some approaches~\cite{ilr,binary-stirring} attempt to randomize the application in different level (e.g., in the instruction level) to increase the bar for the adversary launching ROP attacks. However some attacks sill can

In this paper, we propose a new ROP detection method, which relies on the payload detection and alignment filtering. The method is based on the observations:
\begin{enumerate}
\item \emph{A payload is necessary for a ROP attack to chain the selected gadgets}.
\item \emph{The unaligned gadgets are usually used as the critical elements in a gadget chain.}
\end{enumerate}

%\emph{\textbf{A payload is necessary for a ROP attack to chain the selected gadgets and the unaligned gadgets are usually used as the critical elements in a gadget chain}}.

The alignment filtering attempts to filter the ROP attacks using the unaligned gadgets. ROPTerminator checks each taken branch recorded in the LBR registers with the branch-alignment database generated in the pre-processing phase. Once an unaligned branch record is detected, ROPTerminator will kill the application with no doubt. \emph{The meaning of the alignment filtering is that it increases the bar for the adversary to launch a ROP attack because they have to give up using all unaligned gadgets.}

The payload detection aims to identify ROP payload from the application stack by constructing a gadget chain. If there is no detected gadget chain (e.g., the length of the constructed chain is under a threshold), ROPTerminator decides that no ROP payload is found at this round, and resumes the application execution. Otherwise, ROPTerminator puts the suspicious gadget chain to a global buffer and trigger the feedback confirmation mechanism to verify whether this chain will be executed in future. Once this gadget chain appears in the execution trace, ROPTerminator reports that a ROP attack is detected.

Note that the branch filtering step aims to ensure that there is no ROP attacks executing with unaligned gadgets in the past, and the payload detection attempts to identify all ROP attacks that may perform in the near further.

%In this paper, we propose a new payload checking method to detect ROP attacks. ROPTerminator relies on the information of branch instructions (e.g., branch type, alignment) to identify potential gadget pointers in application stack. We then attempt to construct a gadget chain by analyzing the stack-manipulation instructions (e.g., pop \%eax) in the identified gadgets. If the gadget chaining process terminates without success (e.g., the length of the constructed chain is under a threshold), ROPTerminator decides that no ROP payload is found at this round, and resumes the application execution. Otherwise, ROPTerminator puts the suspicious gadget chain to a buffer and trigger the feedback confirmation mechanism to verify whether this chain will be executed in future. Once this chain is recorded in the execution trace (Section~\ref{sec:lbr}), ROPTerminator reports that an ROP attack is detected.

%The branch and stack-manipulation instruction information could be reliably extracted from the application binary, by using the recursive descent disassembler (e.g., IDA Pro) or the linear scan disassembler (e.g., objdump). The disassembled results can be verified by the technique used in ~\cite{static-disassembly}.

%and the observation of the ROP gadgets (Section~\ref{sec:background}). together with the branch-alignment checking. The basic idea comes from the following observations:

%\begin{enumerate}
%\item The density of the gadget pointer is high in the ROP payload, while it would be quite low in the normal stack.
%    In a stack, the data that point to code space usually are return values and function pointers, but the pointed code sequences are not treated as gadget in most cases.
%    Note that we have proposed a new method to defend against the density dilution behaviour (in Section~\ref{sec:algo}).
%\item The taken branches are aligned in the normal execution, but some of them may be unaligned in the ROP attack.
%    Thus, once we observe that there is an unaligned taken branch, we can ensure that there is a ROP attack executing.
%\end{enumerate}

%This information is relatively easy to get the branch and alignment information comparing with getting CFG from the binary code.
%In our case, we only need to know if a branch instruction is aligned or unaligned, while the CFG requires more information, e.g., the predecessor and successor of a block.
%To extract the alignment information, we can use the recursive descent disassembler (e.g., IDA Pro) or the linear scan disassembler (e.g., objdump). In addition, the results can be verified by leveraging the technique used in ~\cite{static-disassembly}. %Note that such operations also can be done in the pre-processing phase. Thus, we have enough time to verify the correctness of the result. Getting the historical branch records from LBR registers, we can verify if a branch is unaligned in constant time.


%The payload checking needs to verify if the pointed address is a gadget, which implies that 1) the pointed address is in the code region; and 2) there is an indirect branch instruction in the following several instructions. Given that the gadget is shot, the verification is quite fast. In fact, the relative position of the gadget in a binary code/library is fixed. Thus, we can parse the gadget information in the pre-processing phase, and store it in a database. In the runtime, we can get the result in \emph{constant time} by looking up the database table.


%The second challenge is how to collect abundant semantic information for ROP checking. The information is mainly from the source code and the runtime information. The source code can produce lots of useful information, e.g., we can get the complete and accurate control flow graph and call graph for facilitating the ROP checking procedure. Unfortunately, we have no attempt to use the source code according to our goals. Thus, we have to carefully collect information in runtime. Note that the runtime information is accurate but may be incomplete, meaning that it may not induce false alarms.

%To collect runtime information, researchers usually choose to insert some code around the critical execution path by leveraging binary rewriting technique. However, we have to give up this method since we have no attempt to modify the binary code of the protected application.

%\mypara{How to minimize the false alarms}

%The ROP detection phase may introduce false positive and false negative. Specifically,
%The alignment filter mechanism will never introduce false positive, but it may miss catching the ROP attacks that only use aligned gadgets. Fortunately, the payload detection algorithm may be able to handle the missed ROP attacks.%, which will be handled by the payload detection algorithm.

%The payload detection algorithm may introduce false positive, since the adversary can manipulate the input to the target application to intentionally fill a stack buffer with data that contain a fake gadget chain. It may lead to Denial of Service (DoS) attack, if ROPTerminator attempts to stop the application under this situation. The feedback mechanism can eliminate such cases .

 %the ROP checking algorithm. Essentially, the feedback mechanism is to double check whether the gadgets pointed by the \emph{suspicious gadget pointers} are executed. If they are really executed, we then can make sure that it is a real ROP attack.

%It is extremely hard for the adversary to bypass our verification mechanism.
%The adversary may attempt to bypass our verification mechanism by challenging certain observations:

%The adversary may attempt to launch \emph{payload dilution} attack to bypass the payload checking. Specifically, the payload dilution attack is to dilute the density of the gadget pointer by adjusting the $ESP$ position, e.g., the gadget \textit{mov $0x2c$,\%esp; pop \%ebp; ret} attempts to fetch the next gadget pointer by moving $ESP$ up $48$ bytes. We have proposed a novel algorithm to get the real density by smartly calculating the position of $ESP$ (see details in Section~\ref{sec:algo}).

%The adversary may launch the \emph{stack pivoting} attack~\cite{jit-code-reuse} to confuse the ROPTerminator gadget linking process. Essentially, the stack pivoting attack is putting the payload into another memory region (e.g., a heap buffer or the global data region), and manipulating the stack pointer to point to that region. If ROPTerminator still checks the original stack region, the pivoted payload remains unfound. In fact, ROPTerminator can defend against such attacks by checking whether the $ESP$ is still in the stack region. Note that ROPTerminator in the kernel space is able to acquire the stack region information.

%The adversary may leverage the \emph{gadget gluing} attack to change the format of the gadget and bypass ROPTerminator checking. Normally, the direct branch should not appear in a gadget. However, in certain special cases, the code sequence that a direct branch points to may contain a gadget. The adversary may attempt to glue the direct branch to the gadget to form a new gadget. To defend against this attack, ROPTerminator can choose to follow one hop to verify whether there is a gadget at the destination of the branch.


% density checking as the second defense line to
% alignment checking as the last


%Note that the adversary can not conceal the alignment information of the taken-branches since they can not modify the LBR registers.

%There is almost no false negative, since we are able to use the lower bound of the density of gadget pointer as the threshold. Note that even the lower bound of the density is also extremely high according to our density calculation algorithm (i.e., the smarter counting algorithm in Section~\ref{sec:algo}). Thus, it would not produce many false positive. In addition, the feedback mechanism is able to filter the positive cases.


%The first challenge is due to the absence of the side information. The side information may provide a lot of useful information, such as the complete and accurate control flow graph and call graph, which can be used to accurately verify a ROP attack. Missing such information may lead to the inaccuracy (i.e., false positive and false negative) of the ROP verification. Consequently, it may result in the high performance overhead since we need to collect more runtime information to increase the accuracy.


%The second challenge is to achieve low performance overhead without modifying the binary. Without the inserted code raising a signal to trigger the ROP checking, it usually implies to monitor every step of the execution of the protected application. Obviously, this solution will suffer high performance overhead.
