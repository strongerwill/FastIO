\section{Implementation} \label{sec:implementation}
\yueqiang {
implementations:
1) hooks for on-demand enable
2) locks for mechanism
3) data structures in mechanism
4) threshold selection for cache free? or this discussed in design
5) }

\name implements the prototype from two aspects, namely Xen version 4.2.1 and guest kernel version 3.2.0-rc1 as follows.

\subsection{Hypervisor Space}

From a 32-bit field related to page type information, \name was planning to use a redundant bit to represent the cache flag in order to be compatible with its original implementation. However, each bit in the upper 9-bit of the field has its specific use and the lower 23-bit serves as the reference count of current page type, representing at most ($2^23-1$) reference counts of the page type. \name enforces a stricter rule to prevent count overflow, as cache flag occupies the top bit of the 23-bit. Also, \name adds several SLOC in the function \_\_get\_page\_type() to check if a machine has the flag bit. Besides, if each level of cache pool in the guest OS submits a list of cached pages that are going to be freed, \name implements a corresponding hypercall to clear the flag bit of all machine pages, create corresponding entries in the I/O page tables and flush IOTLB.

\subsection{Guest OS Space}

In the PV setting, guest OS is required to work in PAE (i.e., Physical Address Extension) mode. As a result, \name needs three levels of cache pools. Every cache pool begins its lifecycle automatically with system booting up or dynamically during system runtime. A kernel loadable module has been developed for the on-demand activation. 

For the top two levels used for caching PGD (i.e., Page Global Directory) and PMD (i.e., Page Middle Directory), \name maintains a structured single-linked list caching the linear address of each page for each level of cache pool. As the bottom PT (i.e., Page Table) is located in the High Memory, the mapping between its linear and physical addresses is not stable every time the PT pages are allocated/freed by PT functions. \name needs to create a similar list but caching the structured page info of pages. For each cache pool, \name defines cache allocating and freeing functions used to hook existing page-table related functions. In this way, if OS creates/destroys any process, it always fetches pages from or frees them onto the top of the list. Also note that the cache pool is a shared data structure and every cache-access function is a critical section. To prevent concurrent access while support multi-processor, \name makes use of spin locks. 

As discussed above, cache freeing function is responsible for freeing pages into the buddy system if thresholds of the two factors are met, thus a corresponding hypercall should be invoked with a single-linked list of cached pages as parameters. Since the cached page info structures of PT are not known to hypervisor, the cache freeing function needs to transform the structure to get a machine address for a specific cached page right before the hypercall is invoked.

